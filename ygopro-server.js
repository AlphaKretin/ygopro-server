// Generated by CoffeeScript 1.6.3
(function() {
  var Inotify, Room, Struct, User, constants, ctos_follow, ctos_follows, ctos_send, debug, declaration, dialogues, field, freeport, fs, http, inotify, listener, mongoose, name, net, path, proto_structs, request, result, server_listener, settings, spawn, stoc_follow, stoc_follows, stoc_send, stoc_send_chat, stoc_send_random_tip, stoc_send_tip, structs, structs_declaration, tips, type, typedefs, url, _, _i, _len;

  net = require('net');

  http = require('http');

  url = require('url');

  path = require('path');

  fs = require('fs');

  spawn = require('child_process').spawn;

  freeport = require('freeport');

  Struct = require('struct').Struct;

  _ = require('underscore');

  _.str = require('underscore.string');

  _.mixin(_.str.exports());

  _.str.include('Underscore.string', 'string');

  Inotify = require('inotify').Inotify;

  request = require('request');

  structs_declaration = require('./structs.json');

  typedefs = require('./typedefs.json');

  proto_structs = require('./proto_structs.json');

  constants = require('./constants.json');

  settings = require('./config.json');

  Room = (function() {
    Room.all = [];

    function Room(name, port, client) {
      this.name = name;
      this.port = port;
      this.alive = true;
      this.players = [];
      this.dueling = false;
      this.established = false;
      this.pos_name = {};
      this.add_client(client);
      Room.all.push(this);
    }

    Room.prototype["delete"] = function(room) {
      return Room.all.splice(_.indexOf(Room.all, room), 1);
    };

    Room.prototype.add_client = function(client) {
      return this.players.push({
        client: client,
        name: client.player
      });
    };

    Room.prototype.remove_client = function(client, error) {
      var player, _i, _len, _ref, _results;
      this.players = _.reject(this.players, function(player) {
        return player.client === client;
      });
      _ref = this.players;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        _results.push(stoc_send_chat(player.client, "" + client.player + " 离开了游戏" + (error ? ": " + error : '')));
      }
      return _results;
    };

    Room.prototype.toString = function() {
      var player, _ref, _ref1;
      return "room: " + this.name + " " + this.port + " " + ((_ref = this.alive) != null ? _ref : {
        'alive': 'not-alive'
      }) + " " + ((_ref1 = this.dueling) != null ? _ref1 : {
        'dueling': 'not-dueling'
      }) + " [" + ((function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.players;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          player = _ref2[_i];
          _results.push("client " + (typeof player.client) + " server " + (typeof player.server) + " " + player.name + " " + player.pos + ". ");
        }
        return _results;
      }).call(this)) + "] " + (JSON.stringify(this.pos_name));
    };

    Room.find_by_name = function(name) {
      return _.find(this.all, function(room) {
        return room.name === name;
      });
    };

    Room.find_by_port = function(port) {
      return _.find(this.all, function(room) {
        return room.name === port;
      });
    };

    Room.find_by_client = function(client) {
      return _.find(this.all, function(room) {
        return _.some(room.players, function(player) {
          return player.client === client;
        });
      });
    };

    Room.find_by_server = function(server) {
      return _.find(this.all, function(room) {
        return _.some(room.players, function(player) {
          return player.server === server;
        });
      });
    };

    return Room;

  })();

  debug = false;

  if (process.argv[2] === '--debug') {
    settings.port++;
    settings.http_port++;
  }

  structs = {};

  for (name in structs_declaration) {
    declaration = structs_declaration[name];
    result = Struct();
    for (_i = 0, _len = declaration.length; _i < _len; _i++) {
      field = declaration[_i];
      if (field.encoding) {
        switch (field.encoding) {
          case "UTF-16LE":
            result.chars(field.name, field.length * 2, field.encoding);
            break;
          default:
            throw "unsupported encoding: " + file.encoding;
        }
      } else {
        type = field.type;
        if (typedefs[type]) {
          type = typedefs[type];
        }
        if (field.length) {
          result.array(field.name, field.length, type);
        } else {
          if (structs[type]) {
            result.struct(field.name, structs[type]);
          } else {
            result[type](field.name);
          }
        }
      }
    }
    structs[name] = result;
  }

  stoc_follows = {};

  ctos_follows = {};

  stoc_follow = function(proto, synchronous, callback) {
    var key, value, _ref;
    if (typeof proto === 'string') {
      _ref = constants.STOC;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!constants.STOC[proto]) {
        throw "unknown proto";
      }
    }
    return stoc_follows[proto] = {
      callback: callback,
      synchronous: synchronous
    };
  };

  ctos_follow = function(proto, synchronous, callback) {
    var key, value, _ref;
    if (typeof proto === 'string') {
      _ref = constants.CTOS;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!constants.CTOS[proto]) {
        throw "unknown proto";
      }
    }
    return ctos_follows[proto] = {
      callback: callback,
      synchronous: synchronous
    };
  };

  stoc_send = function(socket, proto, info) {
    var buffer, header, key, struct, value, _ref;
    if (typeof info === 'undefined') {
      buffer = "";
    } else if (Buffer.isBuffer(info)) {
      buffer = info;
    } else {
      struct = structs[proto_structs.STOC[proto]];
      struct.allocate();
      struct.set(info);
      buffer = struct.buffer();
    }
    if (typeof proto === 'string') {
      _ref = constants.STOC;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!constants.STOC[proto]) {
        throw "unknown proto";
      }
    }
    header = new Buffer(3);
    header.writeUInt16LE(buffer.length + 1, 0);
    header.writeUInt8(proto, 2);
    socket.write(header);
    if (buffer.length) {
      return socket.write(buffer);
    }
  };

  ctos_send = function(socket, proto, info) {
    var buffer, header, key, struct, value, _ref;
    if (typeof info === 'undefined') {
      buffer = "";
    } else if (Buffer.isBuffer(info)) {
      buffer = info;
    } else {
      struct = structs[proto_structs.CTOS[proto]];
      struct.allocate();
      struct.set(info);
      buffer = struct.buffer();
    }
    if (typeof proto === 'string') {
      _ref = constants.CTOS;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!constants.CTOS[proto]) {
        throw "unknown proto";
      }
    }
    header = new Buffer(3);
    header.writeUInt16LE(buffer.length + 1, 0);
    header.writeUInt8(proto, 2);
    socket.write(header);
    if (buffer.length) {
      return socket.write(buffer);
    }
  };

  stoc_send_chat = function(client, msg, player) {
    if (player == null) {
      player = 8;
    }
    return stoc_send(client, 'CHAT', {
      player: player,
      msg: msg
    });
  };

  server_listener = function(port, client, server) {
    var buffer, stoc_buffer, stoc_message_length, stoc_proto, _j, _len1, _ref;
    client.connected = true;
    console.log("connected " + port);
    stoc_buffer = new Buffer(0);
    stoc_message_length = 0;
    stoc_proto = 0;
    _ref = client.pre_connecion_buffers;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      buffer = _ref[_j];
      server.write(buffer);
    }
    server.on("data", function(data) {
      var b, struct;
      stoc_buffer = Buffer.concat([stoc_buffer, data], stoc_buffer.length + data.length);
      while (true) {
        if (stoc_message_length === 0) {
          if (stoc_buffer.length >= 2) {
            stoc_message_length = stoc_buffer.readUInt16LE(0);
          } else {
            break;
          }
        } else if (stoc_proto === 0) {
          if (stoc_buffer.length >= 3) {
            stoc_proto = stoc_buffer.readUInt8(2);
          } else {
            break;
          }
        } else {
          if (stoc_buffer.length >= 2 + stoc_message_length) {
            if (stoc_follows[stoc_proto]) {
              b = stoc_buffer.slice(3, stoc_message_length - 1 + 3);
              if (struct = structs[proto_structs.STOC[constants.STOC[stoc_proto]]]) {
                struct._setBuff(b);
                setImmediate(stoc_follows[stoc_proto].callback, b, struct.fields, client, server);
              } else {
                setImmediate(stoc_follows[stoc_proto].callback, b, null, client, server);
              }
            }
            stoc_buffer = stoc_buffer.slice(2 + stoc_message_length);
            stoc_message_length = 0;
            stoc_proto = 0;
          } else {
            break;
          }
        }
      }
      if (!(stoc_follows[stoc_proto] && stoc_follows[stoc_proto].synchronous)) {
        return client.write(data);
      }
    });
    server.on("error", function(e) {
      console.log("server error " + e);
      return client.end();
    });
    return server.on("close", function(had_error) {
      console.log("server closed " + had_error);
      return client.end();
    });
  };

  listener = net.createServer(function(client) {
    var ctos_buffer, ctos_message_length, ctos_proto, server;
    client.connected = false;
    ctos_buffer = new Buffer(0);
    ctos_message_length = 0;
    ctos_proto = 0;
    client.pre_connecion_buffers = new Array();
    server = new net.Socket();
    server.on("error", function(e) {
      stoc_send_chat(client, "服务器错误");
      return console.log("server error " + e);
    });
    client.on("data", function(data) {
      var b, struct;
      ctos_buffer = Buffer.concat([ctos_buffer, data], ctos_buffer.length + data.length);
      while (true) {
        if (ctos_message_length === 0) {
          if (ctos_buffer.length >= 2) {
            ctos_message_length = ctos_buffer.readUInt16LE(0);
          } else {
            break;
          }
        } else if (ctos_proto === 0) {
          if (ctos_buffer.length >= 3) {
            ctos_proto = ctos_buffer.readUInt8(2);
          } else {
            break;
          }
        } else {
          if (ctos_buffer.length >= 2 + ctos_message_length) {
            if (ctos_follows[ctos_proto]) {
              b = ctos_buffer.slice(3, ctos_message_length - 1 + 3);
              if (struct = structs[proto_structs.CTOS[constants.CTOS[ctos_proto]]]) {
                struct._setBuff(b);
                setTimeout(ctos_follows[ctos_proto].callback, 0, b, struct.fields, client, server);
              } else {
                setTimeout(ctos_follows[ctos_proto].callback, 0, b, null, client, server);
              }
            }
            ctos_buffer = ctos_buffer.slice(2 + ctos_message_length);
            ctos_message_length = 0;
            ctos_proto = 0;
          } else {
            break;
          }
        }
      }
      if (!(ctos_follows[ctos_proto] && ctos_follows[ctos_proto].synchronous)) {
        if (client.connected) {
          return server.write(data);
        } else {
          return client.pre_connecion_buffers.push(data);
        }
      }
    });
    client.on("error", function(e) {
      var room;
      room = Room.find_by_client(client);
      if (room) {
        room.remove_client(client, e);
      }
      console.log("client error " + e);
      return server.end();
    });
    return client.on("close", function(had_error) {
      var room;
      console.log("client closed " + had_error);
      if (had_error) {
        return;
      }
      room = Room.find_by_client(client);
      if (room) {
        room.remove_client(client);
      }
      return server.end();
    });
  }).listen(settings.port, null, null, function() {
    return console.log("server started on " + settings.ip + ":" + settings.port);
  });

  ctos_follow('PLAYER_INFO', true, function(buffer, info, client, server) {
    return client.player = info.name;
  });

  ctos_follow('JOIN_GAME', false, function(buffer, info, client, server) {
    var room, room_name;
    room_name = info.pass;
    if (info.version !== settings.version) {
      stoc_send(client, 'ERROR_MSG', {
        msg: 4,
        code: settings.version
      });
      return client.end();
    } else if (!room_name.length) {
      stoc_send_chat(client, "房间为空，请修改房间名");
      return stoc_send(client, 'ERROR_MSG', {
        msg: 1,
        code: 2
      });
    } else if (room_name === '[INCORRECT]') {
      stoc_send(client, 'ERROR_MSG', {
        msg: 1,
        code: 1
      });
      return client.end();
    } else {
      if (client.player !== '[INCORRECT]') {
        room = Room.find_by_name(room_name);
        console.log("[join]find_by_room " + room_name + " " + room);
        if (room) {
          room.add_client(client);
          if (room.established) {
            return server.connect(room.port, '127.0.0.1', function() {
              return server_listener(room.port, client, server);
            });
          }
        } else {
          return freeport(function(err, port) {
            var param, process;
            room = Room.find_by_name(room_name);
            console.log("[join freeport]find_by_room " + room_name + " " + room);
            if (room) {
              room.add_client(client);
              if (room.established) {
                return server.connect(room.port, '127.0.0.1', function() {
                  return server_listener(room.port, client, server);
                });
              }
            } else {
              if (err) {
                stoc_send(client, 'ERROR_MSG', {
                  msg: 1,
                  code: 2
                });
                return client.end();
              } else {
                room = new Room(room_name, port, client);
                if (room_name.slice(0, 2) === 'M#') {
                  param = [0, 0, 1, 'F', 'F', 'F', 8000, 5, 1];
                } else if (room_name.slice(0, 2) === 'T#') {
                  param = [0, 0, 2, 'F', 'F', 'F', 8000, 5, 1];
                } else if ((param = room_name.match(/^(\d)?(\d)(\d)(T|F)(T|F)(T|F)(\d+),(\d+),(\d+)/i))) {
                  param.shift();
                  param[0] === parseInt(param[0]);
                } else {
                  param = [0, 0, 0, 'F', 'F', 'F', 8000, 5, 1];
                }
                param.unshift(port);
                process = spawn('./ygopro', param, {
                  cwd: 'ygocore'
                });
                room.process = process;
                process.on('exit', function(code) {
                  console.log("room process " + port + " exited with code " + code);
                  return room["delete"]();
                });
                return process.stdout.once('data', function(data) {
                  room.established = true;
                  return _.each(room.players, function(player) {
                    return server.connect(port, '127.0.0.1', function() {
                      return server_listener(port, player.client, server);
                    });
                  });
                });
              }
            }
          });
        }
      } else {
        stoc_send(client, 'ERROR_MSG', {
          msg: 1,
          code: 2
        });
        return client.end();
      }
    }
  });

  stoc_follow('JOIN_GAME', false, function(buffer, info, client, server) {
    stoc_send(client, 'CHAT', {
      player: 8,
      msg: "Mycard Debugging Server"
    });
    return stoc_send(client, 'CHAT', {
      player: 8,
      msg: "这里是测试中的新服务器, 还不稳定, 随时可能崩溃, 遇到意外请淡定\n                           ˉˉˉˉˉ"
    });
  });

  dialogues = {};

  request({
    url: 'https://my-card.in/dialogues.json',
    json: true
  }, function(error, response, body) {
    dialogues = body;
    return console.log("loaded " + (_.size(body)) + " dialogues");
  });

  stoc_follow('GAME_MSG', false, function(buffer, info, client, server) {
    var card, line, loser_name, msg, room, winner_name, _j, _len1, _ref;
    msg = buffer.readInt8(0);
    if (constants.MSG[msg] === 'SUMMONING' || constants.MSG[msg] === 'SPSUMMONING') {
      card = buffer.readUInt32LE(1);
      if (dialogues[card]) {
        _ref = _.lines(dialogues[card][Math.floor(Math.random() * dialogues[card].length)]);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          line = _ref[_j];
          stoc_send_chat(client, line);
        }
      }
    }
    if (constants.MSG[msg] === 'WIN') {
      room = Room.find_by_client(client);
      if (!room) {
        console.log("[WARN]win: can't find room by player " + client.player);
        return;
      }
      if (_.startsWith(room.name, 'M#') && room.dueling) {
        room.dueling = false;
        loser_name = room.pos_name[buffer.readUInt8(1)];
        winner_name = room.pos_name[1 - buffer.readUInt8(1)];
        return User.findOne({
          name: winner_name
        }, function(err, winner) {
          if (err) {
            return console.log("" + err + " when finding user " + winner_name);
          } else if (!winner) {
            return console.log("user " + winner_name + " not exist");
          } else {
            return User.findOne({
              name: loser_name
            }, function(err, loser) {
              if (err) {
                return console.log("" + err + " when finding user " + loser_name);
              } else if (!loser) {
                return console.log("user " + loser_name + " not exist");
              } else {
                winner.points += 10;
                loser.points -= 5;
                winner.save();
                loser.save();
                console.log("" + winner + " 增加10点积分，现在有" + winner.points + "点");
                return console.log("" + loser + " 减少5点积分，现在有" + loser.points + "点");
              }
            });
          }
        });
      }
    }
  });

  stoc_follow('HS_PLAYER_CHANGE', false, function(buffer, info, client, server) {
    client.ready = info.status & 0xF !== 0;
    client.pos = info.status >> 4;
    return console.log(client.ready, client.pos);
  });

  mongoose = require('mongoose');

  mongoose.connect('mongodb://localhost/mycard');

  User = mongoose.model('User', {
    name: String,
    points: Number
  });

  stoc_follow('HS_PLAYER_ENTER', false, function(buffer, info, client, server) {
    var room;
    room = Room.find_by_client(client);
    if (!room) {
      console.log("[WARN]player_enter: can't find room by player " + client.player);
      return;
    }
    return room.pos_name[info.pos] = info.name;
  });

  http.createServer(function(request, response) {
    if (url.parse(request.url).pathname === '/count.json') {
      response.writeHead(200);
      return response.end(Room.all.length.toString());
    } else {
      response.writeHead(404);
      return response.end();
    }
  }).listen(settings.http_port);

  inotify = new Inotify();

  inotify.addWatch({
    path: 'ygocore/replay',
    watch_for: Inotify.IN_CLOSE_WRITE | Inotify.IN_CREATE | Inotify.IN_MODIFY,
    callback: function(event) {
      var mask, port, room;
      mask = event.mask;
      if (event.name) {
        port = parseInt(path.basename(event.name, '.yrp'));
        room = Room.find_by_port(port);
        if (room) {
          if (mask & Inotify.IN_CREATE) {

          } else if (mask & Inotify.IN_CLOSE_WRITE) {
            return fs.unlink(path.join('ygocore/replay'), function(err) {});
          } else if (mask & Inotify.IN_MODIFY) {
            return room.alive = true;
          }
        }
      } else {
        return console.log('[warn] event without filename');
      }
    }
  });

  setInterval(function() {
    var room, _j, _len1, _ref, _results;
    _ref = Room.all;
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      room = _ref[_j];
      if (room.alive) {
        _results.push(room.alive = false);
      } else {
        console.log("kill room " + room.port);
        _results.push(room.process.kill());
      }
    }
    return _results;
  }, 900000);

  stoc_send_tip = function(client, tip) {
    var line, lines, _j, _len1, _ref, _results;
    lines = _.lines(tip);
    stoc_send_chat(client, "Tip: " + lines[0]);
    _ref = lines.slice(1);
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      line = _ref[_j];
      _results.push(stoc_send_chat(client, line));
    }
    return _results;
  };

  stoc_send_random_tip = function(client) {
    if (tips) {
      return stoc_send_tip(client, tips[Math.floor(Math.random() * tips.length)]);
    }
  };

  tips = null;

  request({
    url: 'https://my-card.in/tips.json',
    json: true
  }, function(error, response, body) {
    tips = body;
    return console.log("loaded " + tips.length + " tips");
  });

  stoc_follow('DUEL_START', false, function(buffer, info, client, server) {
    var room;
    stoc_send_random_tip(client);
    room = Room.find_by_client(client);
    if (!room) {
      console.log("[WARN]duel start: can't find room by player " + client.player);
      return;
    }
    room.dueling = true;
    if (_.startsWith(room.name, 'M#')) {
      return User.findOne({
        name: client.player
      }, function(err, user) {
        if (!user) {
          user = new User({
            name: client.player,
            points: 0
          });
          user.save();
        }
        return stoc_send_chat(client, "积分系统测试中，你现在有" + user.points + "点积分，这些积分以后可能会重置");
      });
    }
  });

  ctos_follow('CHAT', false, function(buffer, info, client, server) {
    if (_.trim(info.msg) === '/tip') {
      return stoc_send_random_tip(client);
    }
  });

  /*
  # 开包大战
  
  packs_weighted_cards = {}
  for pack, cards of require './packs.json'
    packs_weighted_cards[pack] = []
    for card in cards
      for i in [0..card.count]
        packs_weighted_cards[pack].push card.card
  
  console.log packs_weighted_cards
  
  ctos_follow 'UPDATE_DECK', false, (buffer, info, client, server)->
    ctos_send server, 'HS_NOTREADY'
  
    deck = []
    for pack in client.player
      for i in [0...5]
        deck.push packs_weighted_cards[pack][Math.floor(Math.random()*packs_weighted_cards[pack].length)]
  
  
    ctos_send server, 'UPDATE_DECK', {
      mainc: deck.length,
      sidec: 0,
      deckbuf: deck
    }
    ctos_send server, 'HS_READY'
  */


}).call(this);
