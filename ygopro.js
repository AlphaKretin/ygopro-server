// Generated by CoffeeScript 1.6.3
(function() {
  var Struct, declaration, field, name, result, structs_declaration, type, typedefs, _, _i, _len;

  _ = require('underscore');

  _.str = require('underscore.string');

  _.mixin(_.str.exports());

  Struct = require('struct').Struct;

  structs_declaration = require('./structs.json');

  typedefs = require('./typedefs.json');

  this.proto_structs = require('./proto_structs.json');

  this.constants = require('./constants.json');

  this.structs = {};

  for (name in structs_declaration) {
    declaration = structs_declaration[name];
    result = Struct();
    for (_i = 0, _len = declaration.length; _i < _len; _i++) {
      field = declaration[_i];
      if (field.encoding) {
        switch (field.encoding) {
          case "UTF-16LE":
            result.chars(field.name, field.length * 2, field.encoding);
            break;
          default:
            throw "unsupported encoding: " + field.encoding;
        }
      } else {
        type = field.type;
        if (typedefs[type]) {
          type = typedefs[type];
        }
        if (field.length) {
          result.array(field.name, field.length, type);
        } else {
          if (this.structs[type]) {
            result.struct(field.name, this.structs[type]);
          } else {
            result[type](field.name);
          }
        }
      }
    }
    this.structs[name] = result;
  }

  this.stoc_follows = {};

  this.ctos_follows = {};

  this.stoc_follow = function(proto, synchronous, callback) {
    var key, value, _ref;
    if (typeof proto === 'string') {
      _ref = this.constants.STOC;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!this.constants.STOC[proto]) {
        throw "unknown proto";
      }
    }
    return this.stoc_follows[proto] = {
      callback: callback,
      synchronous: synchronous
    };
  };

  this.ctos_follow = function(proto, synchronous, callback) {
    var key, value, _ref;
    if (typeof proto === 'string') {
      _ref = this.constants.CTOS;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!this.constants.CTOS[proto]) {
        throw "unknown proto";
      }
    }
    return this.ctos_follows[proto] = {
      callback: callback,
      synchronous: synchronous
    };
  };

  this.stoc_send = function(socket, proto, info) {
    var buffer, header, key, struct, value, _ref;
    if (typeof info === 'undefined') {
      buffer = "";
    } else if (Buffer.isBuffer(info)) {
      buffer = info;
    } else {
      struct = this.structs[this.proto_structs.STOC[proto]];
      struct.allocate();
      struct.set(info);
      buffer = struct.buffer();
    }
    if (typeof proto === 'string') {
      _ref = this.constants.STOC;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!this.constants.STOC[proto]) {
        throw "unknown proto";
      }
    }
    header = new Buffer(3);
    header.writeUInt16LE(buffer.length + 1, 0);
    header.writeUInt8(proto, 2);
    socket.write(header);
    if (buffer.length) {
      return socket.write(buffer);
    }
  };

  this.ctos_send = function(socket, proto, info) {
    var buffer, header, key, struct, value, _ref;
    if (typeof info === 'undefined') {
      buffer = "";
    } else if (Buffer.isBuffer(info)) {
      buffer = info;
    } else {
      struct = this.structs[this.proto_structs.CTOS[proto]];
      struct.allocate();
      struct.set(info);
      buffer = struct.buffer();
    }
    if (typeof proto === 'string') {
      _ref = this.constants.CTOS;
      for (key in _ref) {
        value = _ref[key];
        if (value === proto) {
          proto = key;
          break;
        }
      }
      if (!this.constants.CTOS[proto]) {
        throw "unknown proto";
      }
    }
    header = new Buffer(3);
    header.writeUInt16LE(buffer.length + 1, 0);
    header.writeUInt8(proto, 2);
    socket.write(header);
    if (buffer.length) {
      return socket.write(buffer);
    }
  };

  this.stoc_send_chat = function(client, msg, player) {
    var line, _j, _len1, _ref, _results;
    if (player == null) {
      player = 8;
    }
    _ref = _.lines(msg);
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      line = _ref[_j];
      _results.push(this.stoc_send(client, 'CHAT', {
        player: player,
        msg: line
      }));
    }
    return _results;
  };

  this.stoc_send_chat_to_room = function(room, msg, player) {
    var client, _j, _k, _len1, _len2, _ref, _ref1, _results;
    if (player == null) {
      player = 8;
    }
    _ref = room.players;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      client = _ref[_j];
      if (client) {
        this.stoc_send_chat(client, msg, player);
      }
    }
    _ref1 = room.watchers;
    _results = [];
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      client = _ref1[_k];
      if (client) {
        _results.push(this.stoc_send_chat(client, msg, player));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

}).call(this);

/*
//@ sourceMappingURL=ygopro.map
*/
